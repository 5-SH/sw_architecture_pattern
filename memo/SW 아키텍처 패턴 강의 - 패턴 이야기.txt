[1]
	패턴 진영 
		hill side
		oppsala, splash
	
	라이브러리 vs 프레임워크
		라이브러리
			함수 집합
			호출의 주도권을 개발자가 가짐
		프레임워크 
			패턴의 집합
			호출의 주도권을 플랫폼이 가짐
	
	디자인 패턴의 핵심 원리
		구현이 아닌 인터페이스에 따라 프로그래밍 하라
			구현 상속 vs 인터페이스 상속
				구현 상속(subclassing)
					java - extends
					재활용성
					런타임 시에 클래스를 동적으로 바꿀 수 없다.
				인터페이스 상속(subtyping)
					java - implement
					다형성
					런타임 시에 클래스 동적 바인딩 가능
			=> 구현 상속 대신 인터페이스 상속을 사용해서 구현하라
			
			브릿지 패턴, 전략 패턴
				구조는 같다
				브릿지 - 인터페이스 변경
				전략 - 구현체 런타임에 변경
				어떤 구조가 한 패턴을 의미하는 것은 아니다
				개념적으로 어떻게 적용되는지 봐야한다
				어떤 부분이 중요한지에 따라 결정됨
			
			모든 것을 다 인터페이스 할 필요는 없다
				많이 참조할 것 같은
				뒷단의 개발이 될 것 같은
				경우
				프론트같이 자주 변경되는 경우는 안써도 됨
	
	클래스 상속 보다는 객체 합성을 더 선호하라
		=> 구현 상속 보다는 객체 합성(서브타이핑 + 합성)을 사용하라
		클래스 상속 vs 객체 합성
		클래스 상속
			동적 변경 안 됨
			white box
		객체 합성
			동적 변경 가능 -> 유연성 확보
			black box

[2]
	책 추천
		OBJECT ORIENTED REMOTING - 네티 등 네트워크 프레임워크 구조 설명
		POSA 2권
		FEARLESS CHANGE - 애자일 적인 조직 운영
	
	패턴은 섬이 아니다.
		패턴은 개별적으로 사용되지 않는다
		패턴을 사용하면 사이드 이펙트가 발생한다
		사이드 이펙트를 해결하기 위해 다른 패턴을 추가로 사용한다
	
	패턴은 만병통치약?
		패턴을 쓴다고 성능이 향상되는건 아니다
		패턴은 비기능적 요구사항에 초점
		기능적, 비기능적 요구사항
			비기능적
				확장성 - scalability, 사용자 늘어나도 확장해 개발 가능
				성능 - 서버가 얼마나 많은 트래픽을 견디는지
				가용성 - 부분적으로 장애가 있더라도 빠르게 복구
		유지보수성
			요구사항을 받아들였을때 많이 안뜯어고치고 수정이 가능한지?
		그 중 확장성, 유지보수성에 특히 초점

[3 패턴으로 가는 길]	
	패턴의 남용
		리소스 제약이 심한 시스템에 유연성 추가?
		삼성에서 홈네트워킹 차세대 만들때
			건물에 들어가는 설비나 전자장비들은 건설사에서 정함
			현장마다 설비에서 사용하는 프로토콜이 모두 다르다 -> 추상화가 어려움
			엄청 유명한 사람을 불러다 설계하고 삼성 홈네트워킹 2.0 만듬
			프로토콜에 유연할 수 있게 파이프&필터 패턴 사용
			런타임 시에 프로토콜을 만들기 때문에 14초 씩 걸림
			해결이 안 됨
		=> 외부 컨설턴트는 내가 가지 제조 분야의 좋은 설계를 주기 힘듬 - 팩트
		확장성이 필요한 부분에 패턴은 상황에 맞게 조율해서 써라
		1.0 일때 좋은 설계를 만들기 어려움
			고객의 요구사항이 클리어 하지 않음
			닷넷 프레임워크도 만들고 나서 폐기가 됨
			처음 겪는 문제라면 애자일 하게 문제를 해결하는 것이 맞음
				end to end 메인 시나리오 만들고 
				추가 요구사항이 들어 올때 마다 수정
		금융은 3~4년 마다 차세대를 함
			금융법이 바뀌기 때문
			금융법 수정을 대응해야 하는데 받아 들일 수 없는 아키텍처라면 결국 뜯어고쳐야 됨
		
		템플릿메소드 패턴
			부모 클래스가 인터페이스가 아님
			부모 클래스의 함수가 구현되어 있지 않고 자식클래스에서 구현되어 있음
			어떻게 흘러가야 하는지 컨트롤 플로우를 Main 문에서 하지 않고 템플릿메소드의 부모 클래스에서 진행
			컨트롤 플로우를 사용자가 관리하지 않고 라이브러리(프레임워크)에서 관리함
			부모가 자식을 호출하지 않고 자식이 부모를 호출함
			=> IoC(헐리우드 원리)
		
		Component Configurator
			설정 파일을 바꾸면 동작이 바뀜
			설정 파일을 읽어서 런타임에 어떤 컴포넌트를 메모리에 올릴지 런타임에 결정
			=> Spring DI Container
			Reflection 을 사용해서 주로 구현
			<-> BCI : 컴파일 할 떄 코드를 변조 -> 런타임 때 변조하는 기능보다 더 빠름
		
		옵저버 패턴(Publisher-Subscriber 패턴)
			Observer = Notifier 통보 받는 자
			헐리우드 원칙
			client -> server 요청이 아닌 server -> client 요청 구조
			날씨 서버 예시
				날씨가 궁금하면 클라이언트가 서버에 자꾸 polling 해야함
				서버에 부하가 너무 심함
				클라이언트는 서버에 날씨 정보를 전달받을 때 자신을 호출할 수 있는 레퍼런스만 전달함
				서버는 날씨가 변경되면 레퍼런스를 통해 클라이언트에게 날씨를 전달하거나 변경된 날씨를 조회하라고 알림
			핸들러
				설정 정보를 읽어서 어떤 동작을 수행할때
				클라이언트가 매번 설정 정보를 읽으면 File I/O Overhead 발생
				File Watcher 를 만들고 파일 변경이 있으면 handler 에게 다시 메모리에 로드하라고 notify 함
				DB 연결 경우에는 문제가 됨
					DB 연결정보가 바뀌게 되면?
					새로운 핸들러 등록 
					새로운 클라이언트는 새로운 핸들러 사용
					기존 클라이언트는 기존 핸들러 사용
					기존 핸들러 아무도 사용 안하면 폐기
		
		SoC(Seperate of Concern)
			
[4 패턴의 구성요소 바로 알기]
	패턴을 언제 사용해야 하는지는 컨텍스트에 있다
	컨텍스트와 문제를 제대로 알아야 정확하게 패턴을 쓸 수 있다
	패턴과 패턴을 연결하는 고리가 컨텍스트
	패턴을 사용하면 발생하는 사이드 이펙트를 이해하고 써야한다
	실 사례를 살펴보는 것이 좋음
	
[5 패턴의 올바른 학습 가이드라인]
	POSA 1,2,3 권 추천
	
